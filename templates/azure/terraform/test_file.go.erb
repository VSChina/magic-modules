<%# lines(autogen_notice :go) -%>
package azurerm

import (
    "fmt"
    "strings"
    "testing"

    "github.com/hashicorp/terraform/helper/acctest"
    "github.com/hashicorp/terraform/helper/resource"
    "github.com/hashicorp/terraform/terraform"
    "github.com/terraform-providers/terraform-provider-azurerm/azurerm/helpers/tf"
    "github.com/terraform-providers/terraform-provider-azurerm/azurerm/utils"
)
<%
    resource_name = "AzureRM" + object.name
    terraform_name = "azurerm_" + object.name.underscore
    properties = object.all_user_properties
    contains_acctests = object.respond_to?(:acctests) && !object.acctests.nil? && !object.acctests.empty?
    provider_name = object.api_name
    provider_client_name = object.azure_sdk_definition.go_client
-%>

<%
    test_hcls = Hash.new
    if contains_acctests
      object.acctests.each do |test|
        test.steps.uniq.each do |name|
          test_hcl, random_vars = build_test_hcl_from_example(name)
          test_hcls[name] = { :hcl => test_hcl, :random_vars => random_vars }
        end
-%>
func TestAcc<%= resource_name -%>_<%= test.name -%>(t *testing.T) {
    data := acceptance.BuildTestData(t, "<%= terraform_name -%>", "test")
    resource.ParallelTest(t, resource.TestCase{
        PreCheck:     func() { acceptance.PreCheck(t) },
        Providers:    acceptance.SupportedProviders,
        CheckDestroy: testCheck<%= resource_name -%>Destroy,
        Steps: []resource.TestStep{
<%      test.steps.each do |step| -%>
<%        props_to_check = get_example_properties_to_check(step, object) -%>
            {
                Config: testAcc<%= resource_name -%>_<%= step -%>(data),
                Check: resource.ComposeTestCheckFunc(
                    testCheck<%= resource_name -%>Exists(data.ResourceName),
<%        props_to_check.each do |propName, propValue| -%>
<%          if propValue == :AttrSet -%>
                    resource.TestCheckResourceAttrSet(data.ResourceName, "<%= propName -%>"),
<%          else -%>
                    resource.TestCheckResourceAttr(data.ResourceName, "<%= propName -%>", "<%= propValue -%>"),
<%          end -%>
<%        end -%>
                ),
            },
<%      end -%>
            data.ImportStep(),
        },
    })
}
<%    end -%>
<%  end -%>

func testCheck<%= resource_name -%>Exists(resourceName string) resource.TestCheckFunc {
    return func(s *terraform.State) error {
        rs, ok := s.RootModule().Resources[resourceName]
        if !ok {
            return fmt.Errorf("<%= object.name.titlecase -%> not found: %s", resourceName)
        }

<%= lines(build_acctest_parameters_from_schema(object.azure_sdk_definition.read, properties, object)) -%>

        client := acceptance.AzureProvider.Meta().(*clients.Client).<%= provider_name -%>.<%= provider_client_name -%>

        ctx := acceptance.AzureProvider.Meta().(*clients.Client).StopContext

        if resp, err := <%= build_sdk_func_invocation(object.azure_sdk_definition.read) -%>; err != nil {
            if utils.ResponseWasNotFound(resp.Response) {
                return <%= build_errorf_with_resource_name("Bad: %s does not exist", false, object.azure_sdk_definition.delete, properties, object) -%>

            }
            return fmt.Errorf("Bad: Get on <%= provider_client_name -%>: %+v", err)
        }

        return nil
    }
}

func testCheck<%= resource_name -%>Destroy(s *terraform.State) error {
    client := acceptance.AzureProvider.Meta().(*clients.Client).<%= provider_name -%>.<%= provider_client_name -%>

    ctx := acceptance.AzureProvider.Meta().(*clients.Client).StopContext

    for _, rs := range s.RootModule().Resources {
        if rs.Type != "<%= terraform_name -%>" {
            continue
        }

<%= lines(build_acctest_parameters_from_schema(object.azure_sdk_definition.read, properties, object)) -%>

        if resp, err := <%= build_sdk_func_invocation(object.azure_sdk_definition.read) -%>; err != nil {
            if !utils.ResponseWasNotFound(resp.Response) {
                return fmt.Errorf("Bad: Get on <%= provider_client_name -%>: %+v", err)
            }
        }

        return nil
    }

    return nil
}

<%
    if contains_acctests
      test_hcls.each do |name, test_hcl|
        uniq_params = test_hcl[:random_vars].uniq(&:parameter_name).sort_by(&:declare_order).map{|p| "#{p.parameter_name} #{p.go_type}"}
-%>
func testAcc<%= resource_name -%>_<%= name -%>(data acceptance.TestData) string {
    return fmt.Sprintf(`
<%=     lines(test_hcl[:hcl]) -%>
`, <%=  test_hcl[:random_vars].map(&:create_expression).join(", ") -%>)
}

<%
      end
    end
-%>